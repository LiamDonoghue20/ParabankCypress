/// <reference types="cypress" />
describe('Querying', () => {
  before(() => {
    cy.visit(
      'https://glebbahmutov.com/cypress-examples/9.0.0/commands/querying',
    )
  })

  describe('cy.get', () => {
    it('button', () => {
      // selects the button using ID
      cy.get('#query-btn').should('contain', 'Button')
      // selects the button using class
      cy.get('.query-btn').should('contain', 'Button')

      // Use CSS selectors just like jQuery
      cy.get('#querying-example .well>button:first').should(
        'contain',
        'Button',
      )
    })

    it('headings', () => {
      // find all H4 + H5 + H6 elements
      // and confirm the minimum number of elements
      // using the "greater" assertion
      cy.get('h4,h5,h6').should('have.length.gt', 1)
    })

    it('with jQuery text selector', () => {
      // selects all table cells with text "Same"
      cy.get('td:contains("Same")').should('have.length', 3)
      // if the text does not have white spaces, no need to quote it
      cy.get('td:contains(Same)').should('have.length', 3)
      // you can find elements NOT having the given text
      cy.get('td:not(:contains(Same))')
        .should('have.length', 1)
        .and('have.text', 'Different')
    })

    it('escape special characters', () => {
      cy.get('#user\\:1234').should('have.text', 'Joe')
      cy.get('.admin\\.user')
        // no need to escape the non-selector text
        .should('have.id', 'user:1234')
    })

    it('find elements without given class', () => {
      cy.get('a.help:not(.external)')
        .should('have.length', 2)
        .within(() => {
          // confirm the two found elements
          cy.root().eq(0).should('have.text', 'Article 2')
          cy.root().eq(1).should('have.text', 'index')
        })
    })

    it('elements with an attribute', () => {
      cy.get('#row-attributes li[line]').should('have.length', 3)
    })

    it('anchor links with specific href', () => {
      cy.get('#specific-href a[href="index.html"]')
        .should('have.length', 1)
        .and('have.text', 'index')
    })

    it('escape special characters in attribute', () => {
      cy.get('[attr\\.aria-label="Attribute example"]')
        .should('have.id', 'escape-attribute')
        // ignore the newline characters by using the assertion "include.text"
        // rather than the assertion "have.text"
        .and('include.text', 'Example')
    })

    it('attribute prefix', () => {
      cy.get('[id^=local-example]').should('have.text', 'first')
    })

    it('attribute suffix', () => {
      cy.get('[id$=example-AF9]').should('have.text', 'second')
    })

    it('attribute contains text', () => {
      // quotes around the text without spaces are optional
      cy.get('a[href*="help"]')
        .should('have.length', 1)
        .and('have.text', 'Link 3')
    })

    it('having attribute disabled', () => {
      // finds both button that have the attribute "disabled"
      cy.get('#few-buttons button[disabled]')
        .should('have.length', 2)
        .first()
        .should('have.text', 'Second')
      // finds the two buttons without the attribute "disabled"
      cy.get('#few-buttons button:not([disabled])')
        .should('have.length', 2)
        .last()
        .should('have.text', 'Fourth')
    })

    it('combine attributes', () => {
      cy.get('#combine-attributes').within(() => {
        cy.get('[id^=my-][id$=-yours]').should('have.text', 'second')
      })
    })

    it('by data attribute', () => {
      cy.get('[data-test-id="test-example"]').should(
        'have.class',
        'example',
      )
      // find the element, confirm its attribute
      cy.get('[data-test-id="test-example"]')
        .invoke('attr', 'data-test-id')
        .should('equal', 'test-example')

      // or you can get an element's CSS property
      cy.get('[data-test-id="test-example"]')
        .invoke('css', 'position')
        .should('equal', 'static')
      cy.get('[data-test-id="test-example"]')
        .should('have.attr', 'data-test-id', 'test-example')
        .and('have.css', 'position', 'static')
    })

    it('AND selector', () => {
      // find all P elements inside the element with id "and-selector-example"
      // and all LI elements inside the element with id "and-selector-example"
      cy.get(
        '#and-selector-example p, #and-selector-example li',
      ).should('have.length', 3)
      // alternative: first find the element with id "and-selector-example"
      // then find P and LI elements
      cy.get('#and-selector-example').within(() => {
        cy.get('p, li').should('have.length', 3)
      })
    })
  })

  describe('contains', () => {
    it('returns an element', () => {
      // finds the first element with the given text
      cy.get('.query-list')
        .contains('apples')
        .should('have.class', 'first')
      // ignore text when matching
      cy.get('.query-list')
        .contains('APPLE', { matchCase: false })
        .should('have.class', 'first')
        .and('have.text', 'apples')

      cy.get('.query-list')
        .contains('bananas')
        .should('have.class', 'third')

      // we can pass a regexp to `.contains()`
      cy.get('.query-list')
        .contains(/^b\w+/)
        .should('have.class', 'third')

      // passing a selector to contains will
      // yield the selector containing the text
      cy.get('div#querying')
        .contains('ul', 'oranges')
        .should('have.class', 'query-list')

      cy.get('.query-button')
        .contains('Save Form')
        .should('have.class', 'btn')
    })

    it('selector and text', () => {
      cy.get('#contains-example').within(() => {
        // finds the immediate element
        cy.contains('Some text').should(
          'have.prop',
          'nodeName',
          'SPAN',
        )
        // find the parent element with "Some text" somewhere inside
        cy.contains('[data-cy=parent]', 'Some text')
          .should('have.prop', 'nodeName', 'DIV') // we found the parent div
          .and('have.css', 'text-decoration')
          // the text-decoration style string includes color and line type
          // we are only interested in the presence of the "underline" keyword
          .should('include', 'underline')
      })
    })

    it('regular expression', () => {
      // ignore case
      cy.contains(/cypress user/i)
      // match text exactly
      cy.contains(/^Cypress User$/)
    })

    it('regular expression with whitespace', () => {
      // find the nickname "Incredible" that can have whitespace around it
      // but cannot have any other characters
      cy.contains('.nickname', /^\s*Incredible\s*$/)
    })

    it('duplicate white spaces', () => {
      // FAILS, cannot find the element while having "  " double space
      // cy.contains('#spaces', 'LEGO:  blocks')
      // solution: find the element and assert its text yourself
      cy.get('#spaces').should(($el) => {
        expect($el).to.have.html('LEGO:  blocks')
      })
      // you can also remove duplicate white spaces before calling cy.contains
      // and for good measure trimp the text we are looking for
      cy.contains(
        '#spaces',
        'LEGO:  blocks'.replace(/\s+/g, ' ').trim(),
      )
    })

    it('extract part of the text', () => {
      cy.contains('#my-name', 'My name is')
        // let's extract the name
        .invoke('text')
        // match a group using a regex
        .invoke('match', /name is (?<name>\w+),/)
        // grab just the specific group "name"
        .its('groups.name')
        .should('equal', 'Gleb')
    })
  })

  describe('.within', () => {
    it('form example', () => {
      // validate placeholder attributes
      cy.get('.query-form').within(() => {
        cy.get('input:first').should(
          'have.attr',
          'placeholder',
          'Email',
        )
        cy.get('input:last').should(
          'have.attr',
          'placeholder',
          'Password',
        )
      })
    })

    it('yields the original element', () => {
      cy.get('#within-yields')
        .within(() => {
          // we are trying to return something
          // from the .within callback,
          // but it won't have any effect
          return cy
            .contains('Child element')
            .should('have.class', 'some-child')
        })
        .should('have.id', 'within-yields')
    })

    it('yields the original element even after cy.wrap', () => {
      cy.get('#wrap-inside-within')
        .within(() => {
          // returning cy.wrap(...) has no effect on the yielded value
          // it will still be the original parent DOM element
          return cy.wrap('a new value')
        })
        .should('have.id', 'wrap-inside-within')
    })

    it('escape', () => {
      cy.get('.the-form').within(() => {
        // escape back find H6
        cy.root()
          .closest('#escape-example')
          .contains('h6', 'Name input')
        // escape and enter text into the input field
        cy.root()
          .closest('#escape-example')
          .find('input#inputName')
          .type('Batman')
      })
    })

    it('picture example', () => {
      cy.get('picture').within(() => {
        // at least 2 source elements
        cy.get('source').should('have.length.gt', 1)
        // single img element
        cy.get('img').should('have.length', 1)
      })
    })

    it('multiple elements', () => {
      cy.get('#fruits li').within(() => {
        cy.root().should('have.length', 2) // there are 2 LI items
        cy.contains('a', 'Apples').should(
          'have.attr',
          'href',
          '/apples',
        )
        cy.contains('a', 'Oranges').should(
          'have.attr',
          'href',
          '/oranges',
        )
      })
    })
  })

  it('root example', () => {
    // By default, root is the document
    cy.root().should('match', 'html')

    cy.get('.query-ul').within(() => {
      // In this within, the root is now the ul DOM element
      cy.root().should('have.class', 'query-ul')
    })
  })

  it('Selecting Elements', () => {
    cy.get('#best-practices').within(() => {
      // Worst - too generic, no context
      cy.get('button').click()

      // Bad. Coupled to styling. Highly subject to change.
      cy.get('.btn.btn-large').click()

      // Average. Coupled to the `name` attribute which has HTML semantics.
      cy.get('[name=submission]').click()

      // Better. But still coupled to styling or JS event listeners.
      cy.get('#main').click()

      // Slightly better. Uses an ID but also ensures the element
      // has an ARIA role attribute
      cy.get('#main[role=button]').click()

      // Much better. But still coupled to text content that may change.
      cy.contains('Submit').click()

      // Best. Insulated from all changes.
      cy.get('[data-cy=submit]').click()
    })
  })

  it('cy.get vs .find', () => {
    cy.get('#comparison')
      .get('div')
      // finds the DIV .test-title outside the #parent
      // and the DIV .feature inside
      .should('have.class', 'test-title')
      .and('have.class', 'feature')
    cy.get('#comparison')
      .find('div')
      // the search is limited to the tree at #comparison element
      .should('have.length', 1)
      .and('have.class', 'feature')
  })
})
