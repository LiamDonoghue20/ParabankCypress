/// <reference types="cypress" />
describe('Spies, Stubs & Clocks', () => {
  before(() => {
    cy.visit(
      'https://glebbahmutov.com/cypress-examples/9.0.0/commands/spies-stubs-clocks',
    )
  })

  describe('cy.spy()', () => {
    it('wrap a method in a spy', () => {
      const obj = {
        foo() {},
      }

      const spy = cy.spy(obj, 'foo').as('anyArgs')

      obj.foo()

      // assert against the spy directly
      expect(spy).to.be.called
      // or get the spy via its reference
      cy.get('@anyArgs').should('have.been.called')
    })

    it('retries until assertions pass', () => {
      const obj2 = {
        foo() {},
      }

      cy.spy(obj2, 'foo').as('foo')

      setTimeout(() => {
        obj2.foo()
      }, 500)

      setTimeout(() => {
        obj2.foo()
      }, 2500)

      cy.get('@foo').should('have.been.calledTwice')
    })

    it('returned value', () => {
      const calc = {
        add(a, b) {
          return a + b
        },
      }
      cy.spy(calc, 'add').as('add')
      expect(calc.add(4, 5), 'sum').to.equal(9)
      cy.get('@add').should('have.returned', 9)
      // if there are several calls
      calc.add(1, 2)
      calc.add(100, 200)
      // the assertion will pass if at least one returned 3
      cy.get('@add').should('have.returned', 3)
    })

    it('resolved values', () => {
      const calc = {
        async add(a, b) {
          const sum = await Cypress.Promise.resolve(a + b).delay(1000)
          return sum
        },
      }
      cy.spy(calc, 'add').as('add')
      // wait for the promise to resolve
      // then confirm its resolved value
      cy.wrap(calc.add(4, 5)).should('equal', 9)
      // make a few more calls
      cy.wrap(calc.add(1, 90)).should('equal', 91)
      cy.wrap(calc.add(-5, -8)).should('equal', -13)
      // example of confirming one of the calls used add(4, 5)
      cy.get('@add').should('have.been.calledWith', 4, 5)
      // now let's confirm the resolved values
      // first we need to wait for all promises to resolve
      cy.get('@add')
        .its('returnValues')
        // yields N promises, let's wait for them to resolve
        // in this test they should be resolved already
        // since we used cy.wrap() individually
        .then(Promise.all.bind(Promise))
        // alternative: to avoid the wrong "this" value when using Promise.all
        // .then((ps) => Promise.all(ps))
        .should('deep.equal', [9, 91, -13])
    })
  })

  describe('cy.spy and cy.stub', () => {
    it('checking arguments', () => {
      const person = {
        setName(first, last) {
          this.name = first + ' ' + last
        },
      }

      cy.spy(person, 'setName').as('setName')
      // simulate the application calling the method
      // after some random delay
      setTimeout(() => {
        person.setName('Joe', 'Smith')
      }, Math.random() * 2000)
      // check if the spy was called
      cy.get('@setName').should('have.been.called')
      // check if the spy was called exactly once
      cy.get('@setName').should('have.been.calledOnce')
      // check if the spy was called with first argument 'Joe'
      // the call might have had more arguments, but we do not check them
      cy.get('@setName').should('have.been.calledOnceWith', 'Joe')
      // check if the spy was called with these arguments
      cy.get('@setName').should(
        'have.been.calledOnceWith',
        'Joe',
        'Smith',
      )
      // check if the spy was called once with a string and "Smith"
      cy.get('@setName').should(
        'have.been.calledOnceWith',
        Cypress.sinon.match.string,
        'Smith',
      )
      // verify the property was set
      cy.wrap(person).should('have.property', 'name', 'Joe Smith')
    })

    it('match call arguments using Sinon matchers', () => {
      // see all possible matchers at
      // https://sinonjs.org/releases/latest/matchers/
      const calculator = {
        /**
         * returns the sum of two arguments
         * @param a {number}
         * @param b {number}
         */
        add(a, b) {
          return a + b
        },
      }

      const spy = cy.spy(calculator, 'add').as('add')

      expect(calculator.add(2, 3)).to.equal(5)

      // if we want to assert the exact values used during the call
      expect(spy).to.be.calledWith(2, 3)

      // let's confirm "add" method was called with two numbers
      expect(spy).to.be.calledWith(
        Cypress.sinon.match.number,
        Cypress.sinon.match.number,
      )

      // alternatively, provide the value to match
      expect(spy).to.be.calledWith(
        Cypress.sinon.match(2),
        Cypress.sinon.match(3),
      )

      // match any value
      expect(spy).to.be.calledWith(Cypress.sinon.match.any, 3)

      // match any value from a list
      expect(spy).to.be.calledWith(
        Cypress.sinon.match.in([1, 2, 3]),
        3,
      )

      /**
       * Returns true if the given number is event
       * @param {number} x
       */
      const isEven = (x) => x % 2 === 0

      // expect the value to pass a custom predicate function
      // the second argument to "sinon.match(predicate, message)" is
      // shown if the predicate does not pass and assertion fails
      expect(spy).to.be.calledWith(
        Cypress.sinon.match(isEven, 'isEven'),
        3,
      )

      /**
       * Returns a function that checks if a given number is larger than the limit
       * @param {number} limit
       * @returns {(x: number) => boolean}
       */
      const isGreaterThan = (limit) => (x) => x > limit

      /**
       * Returns a function that checks if a given number is less than the limit
       * @param {number} limit
       * @returns {(x: number) => boolean}
       */
      const isLessThan = (limit) => (x) => x < limit

      // you can combine several matchers using "and", "or"
      expect(spy).to.be.calledWith(
        Cypress.sinon.match.number,
        Cypress.sinon
          .match(isGreaterThan(2), '> 2')
          .and(Cypress.sinon.match(isLessThan(4), '< 4')),
      )

      expect(spy).to.be.calledWith(
        Cypress.sinon.match.number,
        Cypress.sinon
          .match(isGreaterThan(200), '> 200')
          .or(Cypress.sinon.match(3)),
      )

      // matchers can be used from BDD assertions
      cy.get('@add').should(
        'have.been.calledWith',
        Cypress.sinon.match.number,
        Cypress.sinon.match(3),
      )

      // you can alias matchers for shorter test code
      const { match: M } = Cypress.sinon

      cy.get('@add').should('have.been.calledWith', M.number, M(3))
    })

    it('call count', () => {
      // first, let's spy on the console.log method
      cy.window()
        .its('console')
        .then((console) => cy.spy(console, 'log').as('log'))
      // second, act on the UI
      cy.get('#greet').click().click().click()
      // third assert the spy was called three times
      cy.get('@log').its('callCount').should('eq', 3)
    })

    it('reset history', () => {
      // test subject
      const person = {
        age: 0,
        birthday() {
          this.age += 1
        },
      }
      // spy on the subject's method
      cy.spy(person, 'birthday').as('birthday')
      cy.wrap(person)
        .its('age')
        .should('equal', 0)
        .then(() => {
          // the application calls the method twice
          person.birthday()
          person.birthday()
        })
      // verify the spy recorded two calls
      cy.get('@birthday').should('have.been.calledTwice')
      cy.wrap(person)
        .its('age')
        .should('equal', 2)
        .then(() => {
          person.birthday()
          person.birthday()
        })
      cy.get('@birthday').its('callCount').should('equal', 4)
      cy.log('**reset history**')
      cy.get('@birthday').invoke('resetHistory')
      // the spy call count and the history have been cleared
      cy.get('@birthday').its('callCount').should('equal', 0)
      cy.get('@birthday').should('not.have.been.called')
    })
  })

  describe('cy.stub()', () => {
    it('replace a method with a stub', () => {
      const obj = {
        /**
         * prints both arguments to the console
         * @param a {string}
         * @param b {string}
         */
        foo(a, b) {
          // eslint-disable-next-line no-console
          console.log('a', a, 'b', b)
        },
      }

      const stub = cy.stub(obj, 'foo')

      obj.foo('foo', 'bar')

      expect(stub).to.be.called
    })

    it('returns different values', () => {
      cy.window().then((w) => {
        // see how to use Sinon stubs
        // https://sinonjs.org/releases/v10.0.0/stubs/
        cy.stub(w, 'prompt')
          .onFirstCall()
          .returns('green')
          .onSecondCall()
          .returns('red')
          // after the first 2 calls, always return purple
          .returns('purple')
          // give the stub an alias
          // so we can check the number of calls later
          .as('color-stub')
      })
      cy.get('#fav-color').click()
      cy.contains('#color-output', 'green')
      cy.get('#fav-color').click()
      cy.contains('#color-output', 'red')
      cy.get('#fav-color').click().click().click()
      cy.contains('#color-output', 'purple')
      cy.get('@color-stub').should('have.property', 'callCount', 5)
    })

    it('returns different dynamic values', () => {
      cy.window().then((w) => {
        const colors = ['green', 'red']

        // see how to use Sinon stubs
        // https://sinonjs.org/releases/v10.0.0/stubs/
        const s = cy.stub(w, 'prompt')
        colors.forEach(function (color, k) {
          s.onCall(k).returns(color)
        })
        // after that always return purple
        s.returns('purple')
          // give the stub an alias
          // so we can check the number of calls later
          .as('colors-stub')
      })
      cy.get('#fav-colors').click()
      cy.contains('#colors-output', 'green')
      cy.get('#fav-colors').click()
      cy.contains('#colors-output', 'red')
      cy.get('#fav-colors').click().click().click()
      cy.contains('#colors-output', 'purple')
      cy.get('@colors-stub').should('have.property', 'callCount', 5)
    })

    it('save under an alias', () => {
      const obj = {
        foo() {},
      }

      cy.stub(obj, 'foo').as('foo')
      obj.foo('foo', 'bar')

      // access the stub using alias
      cy.get('@foo').should('have.been.called')
    })

    it('restore', () => {
      const person = {
        getName() {
          return 'Joe'
        },
      }

      expect(person.getName(), 'true name').to.equal('Joe')
      cy.stub(person, 'getName').returns('Cliff')
      expect(person.getName(), 'mock name').to.equal('Cliff')
      // restore the original method
      person.getName.restore()
      expect(person.getName(), 'restored name').to.equal('Joe')
    })

    it('restore from an alias', () => {
      const person = {
        getName() {
          return 'Joe'
        },
      }

      expect(person.getName(), 'true name').to.equal('Joe')
      cy.stub(person, 'getName').returns('Cliff').as('getName')
      expect(person.getName(), 'mock name').to.equal('Cliff')
      cy.get('@getName')
        .should('have.been.calledOnce')
        .invoke('restore')
        .then(() => {
          expect(person.getName(), 'restored name').to.equal('Joe')
        })
    })

    it('matches depending on arguments', () => {
      // see all possible matchers at
      // https://sinonjs.org/releases/latest/matchers/
      const greeter = {
        /**
         * Greets a person
         * @param {string} name
         */
        greet(name) {
          return `Hello, ${name}!`
        },
      }

      const stub = cy.stub(greeter, 'greet')
      stub.callThrough() // if you want non-matched calls to call the real method
      stub.withArgs(Cypress.sinon.match.string).returns('Hi')
      stub
        .withArgs(Cypress.sinon.match.number)
        .throws(new Error('Invalid name'))

      expect(greeter.greet('World')).to.equal('Hi')
      // @ts-ignore
      expect(() => greeter.greet(42)).to.throw('Invalid name')
      expect(greeter.greet).to.have.been.calledTwice

      // non-matched calls goes the actual method
      // @ts-ignore
      expect(greeter.greet()).to.equal('Hello, undefined!')
    })

    it('property', () => {
      const person = {
        name: 'Joe',
        getName() {
          return this.name
        },
      }
      expect(person.getName(), 'real name').to.equal('Joe')
      // change the property using cy.stub
      cy.stub(person, 'name').value('Mike')
      cy.then(() => {
        expect(person.getName(), 'stub name').to.equal('Mike')
      })
    })

    it('method is inside application', () => {
      cy.window()
        .its('actions')
        .then((actions) => {
          cy.stub(actions, 'alertTheUser').as('alerted')
        })
      cy.get('#alerter').click()
      cy.get('@alerted').should('have.been.called')
    })

    it('call the original method', () => {
      const person = {
        getName() {
          return 'Joe'
        },
      }

      cy.stub(person, 'getName').callsFake(() => {
        // call the real person.getName()
        return (
          person.getName
            .wrappedMethod()
            // but then reverse the returned string
            .split('')
            .reverse()
            .join('')
        )
      })
      expect(person.getName()).to.equal('eoJ')
    })

    it('check the order of calls', () => {
      const cart = {
        init() {
          return 'initialized'
        },
        finalize() {
          return 'finalized'
        },
        execute() {
          this.init()
          this.finalize()
        },
      }
      cy.spy(cart, 'init')
      cy.spy(cart, 'finalize')
      cart.execute()
      // confirm the "init" method was called before the "finalize" method
      expect(cart.init).to.have.been.calledBefore(cart.finalize)
    })

    it('stub window.alert', () => {
      cy.window().then((win) => {
        cy.stub(win, 'alert').as('alert')
      })
      cy.get('#sayhi').click()
      cy.get('@alert').should(
        'have.been.calledOnceWith',
        'Hello there!',
      )
      // the application can trigger the alert several times
      cy.get('#sayhi').click().click()
      // we can confirm the total number of calls
      cy.get('@alert').its('callCount').should('equal', 3)
    })

    it('stub window.prompt', () => {
      cy.window().then((win) => {
        cy.stub(win, 'prompt').returns('Cy')
        cy.stub(win, 'alert').as('alert')
      })
      cy.get('#greet-by-name').click()
      cy.get('@alert').should('have.been.calledOnceWith', 'Hello Cy')
    })
  })

  describe('clock', () => {
    it('set the application clock', () => {
      // create the date in UTC so its always the same
      // no matter what local timezone the browser is running in
      const now = new Date(Date.UTC(2017, 2, 14)).getTime()

      cy.clock(now)
      cy.get('#clock-div').click().should('have.text', '1489449600')
    })

    it('does not change the spec clock', () => {
      cy.window().its('Date').should('not.equal', Date)
      const specNow = new Date()
      const now = new Date(Date.UTC(2017, 2, 14)).getTime()
      cy.clock(now) // sets the application clock and pause time
        .then(() => {
          // spec clock keeps ticking
          const specNow2 = new Date()
          // confirm by comparing the timestamps in milliseconds
          expect(+specNow2, 'spec timestamps').to.be.greaterThan(
            +specNow,
          )
        })
      // but the application's time is frozen
      cy.window()
        .its('Date')
        .then((appDate) => {
          const appNow = new appDate()
          expect(+appNow, 'application timestamps')
            .to.equal(+now)
            .and.to.equal(1489449600000) // the timestamp in milliseconds
        })
      // we can advance the application clock by 5 seconds
      cy.tick(5000)
      cy.window()
        .its('Date')
        .then((appDate) => {
          const appNow = new appDate()
          expect(
            +appNow,
            'timestamp after 5 synthetic seconds',
          ).to.equal(1489449605000)
        })
        // meanwhile the spec clock only advanced by probably less than 200ms
        .then(() => {
          const specNow3 = new Date()
          expect(
            +specNow3,
            'elapsed on the spec clock',
          ).to.be.lessThan(+specNow + 200)
        })
    })
  })

  it('tick', () => {
    // create the date in UTC so its always the same
    // no matter what local timezone the browser is running in
    const now = new Date(Date.UTC(2017, 2, 14)).getTime()

    cy.clock(now)
    cy.get('#tick-div').click().should('have.text', '1489449600')
    cy.tick(10000) // 10 seconds passed
    cy.get('#tick-div').click().should('have.text', '1489449610')
  })
})
