/// <reference types="cypress" />
describe('Assertions', () => {
  before(() => {
    cy.visit(
      'https://glebbahmutov.com/cypress-examples/9.0.0/commands/assertions',
    )
  })

  describe('Implicit Assertions', () => {
    it('.should() - make an assertion about the current subject', () => {
      cy.get('.assertion-table')
        .find('tbody tr:last')
        .should('have.class', 'success')
        .find('td')
        .first()
        // checking the text of the  element in various ways
        .should('have.text', 'Column content')
        .should('contain', 'Column content')
        .should('have.html', 'Column content')
        // chai-jquery uses "is()" to check if element matches selector
        .should('match', 'td')
        // to match text content against a regular expression
        // first need to invoke jQuery method text()
        // and then match using regular expression
        .invoke('text')
        .should('match', /column content/i)

      // a better way to check element's text content against a regular expression
      // is to use "cy.contains"
      // https://on.cypress.io/contains
      cy.get('.assertion-table')
        .find('tbody tr:last')
        // finds first  element with text content matching regular expression
        .contains('td', /column content/i)
        .should('be.visible')
    })

    it('.should() - input elements have value', () => {
      cy.get('#rent').type('630.00').should('have.value', '630.00')
    })

    it('.should() - non-input elements contain text', () => {
      cy.get('#text-example').should('contain', 'brown fox')
    })

    it('.should() - HTML element tag', () => {
      cy.get('#tag-example').should(
        'have.prop',
        'nodeName',
        'MARQUEE',
      )
    })

    it('.should() - text with newlines', () => {
      cy.get('#newlines-example')
        // cannot use "have.text" because it requires
        // and exact match, and the element has "\n...\n"
        // .should('have.text', 'hello, there!')
        // if you want to perform specific text transforms
        // before checking it, do it inside a should(cb) function
        .should(($el) => {
          // yget and trim the text before comparing
          const text = $el.text().trim()
          expect(text).to.equal('hello, there!')
        })
        // the "include.text" assertion only checks part of the text
        .and('include.text', 'hello, there!')

      // cy.contains uses partial text match too
      cy.contains('#newlines-example', 'hello, there!')
    })

    it('.should() - html entities', () => {
      cy.get('#y-value')
        // use the text value of the HTML entity
        .should('have.html', '√y')
        // "have.html", "have.text", and "contain"
        // assertions work the same with text
        .and('have.text', '√y')
        .and('contain', '√y')
      // a utility for converting HTML entities into text
      const encode = (s) => {
        const p = document.createElement('p')
        p.innerHTML = s // encodes
        return p.innerText
      }
      cy.get('#y-value').should('have.text', encode('&radic;y'))
    })

    it('.should() - placeholder attribute', () => {
      cy.get('#inputEmail').should(
        'have.attr',
        'placeholder',
        'Email',
      )
    })

    it('.should() - visible non-empty text', () => {
      // if we know the precise text we are looking for
      cy.get('#greeting')
        .should('be.visible')
        .and('have.text', 'Hello, there!')
      // if we do not know the text
      cy.get('#greeting')
        .should('be.visible')
        .invoke('text')
        .should('be.a', 'string')
        .and('be.not.empty')
    })

    it('.should() - partial text match', () => {
      cy.get('#parent-element')
        // we only know a part of the text somewhere
        // inside the element
        .should('include.text', 'at the start')
        // "include.text" and "contain" are synonym assertions
        // to find partial text match
        .and('contain', 'some text afterwards')
        // the text inside the child element also counts
        .and('contain', 'main content')
      cy.get('#parent-element')
        // if we use cy.contains command
        // we find the child <span> element
        .contains('main')
        .should('have.class', 'inner')
    })

    it('.should() - visibility of multiple elements', () => {
      cy.get('#few-elements li')
        .should('be.visible')
        .and('have.length', 3)
      // while the second element is still invisible
      cy.contains('#few-elements li', 'second').should(
        'not.be.visible',
      )
      // we can use jQuery selector :visible to get just the visible elements
      cy.get('#few-elements li:visible').should('have.length', 2)
      // we can filter elements to get just the invisible elements
      cy.get('#few-elements li')
        .not(':visible')
        .should('have.length', 1)
        .and('have.text', 'second')
    })

    it('.should() - elements becoming invisible', () => {
      cy.get('#multiple-elements li')
        .should('have.length', 3)
        .and('be.visible')
      cy.get('#hide-multiple-elements').click()
      cy.get('#multiple-elements li')
        // the elements still exist in the DOM
        .should('exist')
        .and('have.length', 3)
        // but should not be visible to the user
        .and('not.be.visible')
    })

    it('.should() - text matching the regular expression', () => {
      cy.get('#a-greeting')
        .invoke('text')
        .should('match', /^Hello/)
      // tip: use cy.contains to find element with text
      // matching a regular expression
      cy.contains('#a-greeting', /^Hello/)
    })

    it('.should() - convert text to number', () => {
      cy.get('#num-example .messages')
        .invoke('text')
        .then(parseInt)
        .should('equal', 4)
        // if you do not know the exact expected number
        // use range assertions, like "greater than", "within"
        .and('be.gt', 0)
        .and('be.within', 0, 10)
      // use command + single assertion callback
      cy.get('#num-example .messages').should(($el) => {
        const n = parseInt($el.text())
        expect(n, 'number of messages')
          .to.be.a('number')
          .and.be.within(0, 10)
      })
    })

    it('.should() - OR match', () => {
      cy.get('#or-match')
        .invoke('text')
        .should('match', /^(Joe|Mary)$/)
      // the same can be done using cy.contains command
      cy.contains('#or-match', /^(Joe|Mary)$/)
    })

    it('.should() - disabled element', () => {
      cy.get('#example-input')
        .should('be.disabled')
        // let's enable this element from the test
        .invoke('prop', 'disabled', false)
      cy.get('#example-input')
        // we can use "enabled" assertion
        .should('be.enabled')
        // or negate the "disabled" assertion
        .and('not.be.disabled')
    })

    it('.should() - data attributes', () => {
      cy.contains('#data-attributes li', 'first')
        // "data" object converts names to camel case
        .should('have.data', 'testId', 'first')
        // the assertion yields the value of the data attribute
        .should('equal', 'first')

      cy.contains('#data-attributes li', 'second')
        // first assertion confirms there is such "data-x" property
        .should('have.data', 'e2e')
        // and yields the value that we assert in the next assertion
        .should('equal', 'second')

      // multiple "data-" properties need multiple commands
      cy.contains('#data-attributes li', 'third').should(
        'have.data',
        'e2e',
        'one',
      )
      cy.contains('#data-attributes li', 'third').should(
        'have.data',
        'cy',
        'two',
      )
      // or a single "data()" call to get an object of values
      cy.contains('#data-attributes li', 'third')
        .invoke('data')
        .should('deep.equal', {
          e2e: 'one',
          cy: 'two',
        })
    })

    it('.and() - chain multiple assertions together', () => {
      // https://on.cypress.io/and
      cy.get('.assertions-link')
        .should('have.class', 'active')
        .and('have.attr', 'href')
        .and('include', 'cypress.io')
    })

    it('.should() - keeps the original subject', () => {
      const employee = {
        person: {
          name: {
            first: 'Joe',
            last: 'Smith',
          },
        },
      }
      cy.wrap(employee)
        .should('have.key', 'person')
        .then((x) => {
          // we are still working with the entire object
          expect(x).to.equal(employee)
        })
    })

    it('.should() - have.property changes the subject', () => {
      const employee = {
        person: {
          name: {
            first: 'Joe',
            last: 'Smith',
          },
        },
      }
      cy.wrap(employee)
        .should('have.property', 'person')
        .then((x) => {
          // the current subject has been changed to employee.person
          expect(x).to.equal(employee.person)
          expect(x).to.have.key('name')
        })
      // Tip: you can use another implicit assertion to check the yielded property
      cy.wrap(employee) // full object
        .should('have.property', 'person') // employee.person
        .should('equal', employee.person) // still employee.person
        .and('have.key', 'name') // still employee.person
        // still employee.person because have.key does not change the subject
        .should('equal', employee.person)
    })

    it('.should() - multiple properties', () => {
      const person = {
        firstName: 'Joe',
        lastName: 'Smith',
        age: 29,
      }
      cy.wrap(person).should('deep.include', {
        firstName: 'Joe',
        lastName: 'Smith',
      })
    })

    it('.should() - have.attr changes the subject', () => {
      cy.get('[data-cy=subject-example]')
        .should('have.attr', 'style')
        .then((x) => {
          // x is the complete style attribute
          const withoutWhiteSpace = x.replace(/\s/g, '')
          expect(withoutWhiteSpace).to.equal(
            'color:orange;background-color:green;',
          )
        })
      // we can remove the whitespace by invoking the method
      // on the yielded subject
      cy.get('[data-cy=subject-example]') // jQuery element
        .should('have.attr', 'style') // string attribute
        .invoke('replace', /\s/g, '') // string without whitespace
        .should('equal', 'color:orange;background-color:green;')
    })

    it('.should() - have.attr with a dot', () => {
      // confirm the element has the attribute
      cy.get('#escape-attribute').should(
        'have.attr',
        'attr.aria-label',
      )
      // confirm the element has the attribute and that attribute
      // has the specific value
      cy.get('#escape-attribute').should(
        'have.attr',
        'attr.aria-label',
        'Attribute example',
      )
    })

    it('.should() - have.attr matching part of the string', () => {
      cy.get('#my-link')
        .should('have.attr', 'href')
        // check if the href attribute includes given string
        .and('include', 'link-')
      // we can use a regular expression
      cy.get('#my-link')
        .should('have.attr', 'href')
        .and('match', /\/link\-\d+/)
    })

    it('.should() - have.prop changes the subject', () => {
      cy.get('.first')
        .should('have.prop', 'class')
        .then((x) => {
          // x is the class prop
          expect(x).to.equal('first second')
        })
    })
  })

  describe('Explicit Assertions', () => {
    it('expect - make an assertion about a specified subject', () => {
      expect(true).to.be.true

      const o = { foo: 'bar' }
      expect(o).to.equal(o)
      expect(o).to.deep.equal({ foo: 'bar' })

      // matching text using regular expression
      expect('FooBar').to.match(/bar$/i)

      // check if the response status code is successful
      const statusCode = 204
      expect(statusCode, 'status code').to.be.within(200, 399)
    })

    it('expect - compare two lists', () => {
      const firstList = []
      const secondList = []
      // let's get the first list of strings
      cy.get('#first li').each(($li) => {
        firstList.push($li.text())
      })
      cy.get('#second li')
        .each(($li) => {
          secondList.push($li.text())
        })
        .then(() => {
          // when this callback runs, both lists will be populated
          expect(firstList).to.include.members(secondList)
        })
    })

    it('assert - assert shape of an object', () => {
      const person = {
        name: 'Joe',
        age: 20,
      }

      assert.isObject(person, 'value is object')
    })
  })

  describe('Should(cb)', () => {
    it('pass your own callback function to should()', () => {
      // Pass a function to should that can have any number
      // of explicit assertions within it.
      // The ".should(cb)" function will be retried
      // automatically until it passes all your explicit assertions or times out.
      cy.get('.assertions-p')
        .find('p')
        .should(($p) => {
          // https://on.cypress.io/$
          // return an array of texts from all of the p's
          // @ts-ignore TS6133 unused variable
          const texts = $p.map((i, el) => Cypress.$(el).text())

          // jquery map returns jquery object
          // and .get() convert this to simple array
          const paragraphs = texts.get()

          // array should have length of 3
          expect(paragraphs, 'has 3 paragraphs').to.have.length(3)

          // use second argument to expect(...) to provide clear
          // message with each assertion
          expect(
            paragraphs,
            'has expected text in each paragraph',
          ).to.deep.eq([
            'Some text from first p',
            'More text from second p',
            'And even more text from third p',
          ])
        })
    })

    it('finds element by class name regex', () => {
      cy.get('.docs-header')
        .find('div')
        // .should(cb) callback function will be retried
        .should(($div) => {
          expect($div).to.have.length(1)

          const className = $div[0].className

          expect(className).to.match(/heading-/)
        })
        // .then(cb) callback is not retried,
        // it either passes or fails
        .then(($div) => {
          expect($div, 'text content').to.have.text('Introduction')
        })
    })

    it('can throw any error', () => {
      cy.get('.docs-header-example')
        .find('div')
        .should(($div) => {
          if ($div.length !== 1) {
            // you can throw your own errors
            throw new Error('Did not find 1 element')
          }

          const className = $div[0].className

          if (!className.match(/heading-/)) {
            throw new Error(
              `Could not find class "heading-" in ${className}`,
            )
          }
        })
    })

    it('matches unknown text between two elements', () => {
      /**
       * Text from the first element.
       * @type {string}
       */
      let text

      /**
       * Normalizes passed text,
       * useful before comparing text with spaces and different capitalization.
       * @param {string} s Text to normalize
       */
      const normalizeText = (s) => s.replace(/\s/g, '').toLowerCase()

      cy.get('.two-elements')
        .find('.first')
        .then(($first) => {
          // save text from the first element
          text = normalizeText($first.text())
        })

      cy.get('.two-elements')
        .find('.second')
        .should(($div) => {
          // we can massage text before comparing
          const secondText = normalizeText($div.text())

          expect(secondText, 'second text').to.equal(text)
        })
    })

    it('retries the should callback until assertions pass', () => {
      cy.get('#random-number').should(($div) => {
        const n = parseFloat($div.text())

        expect(n).to.be.gte(1).and.be.lte(10)
      })
    })

    it('retries in vain', () => {
      // works, but is NOT recommended
      // because it will retry the assertion even if the object never changes
      // until the command timeout passes
      cy.wrap({ name: 'Joe' }).should((o) => {
        expect(o).to.have.property('name', 'Joe')
      })
      // recommended: using .then to immediately fail
      // if the assertion fails
      cy.wrap({ name: 'Joe' }).then((o) => {
        expect(o).to.have.property('name', 'Joe')
      })
    })
  })

  describe('Multiple assertions', () => {
    it('split the command', () => {
      // ⛔️ DOES NOT WORK
      // cy.get('#load-something').click()
      // cy.get('#loading').should('be.visible').and('not.be.visible')
      // ✅ THE CORRECT WAY
      cy.get('#load-something').click()
      cy.get('#loading').should('be.visible')
      cy.get('#loading').should('not.be.visible')
      cy.get('#loading')
        .should('exist')
        .and('have.text', 'Loading ...')
    })
  })

  it('Array assertions', () => {
    const arr = ['Apples', 'Bananas', 'Grapes']
    // assert that cy.wrap yields the same array reference
    // as we passed into it
    cy.wrap(arr).should('equal', arr)
    // assert the yielded array has the expected items inside
    cy.wrap(arr)
      .invoke('reverse')
      .should('deep.equal', ['Grapes', 'Bananas', 'Apples'])
  })

  describe('Objects', () => {
    it('has a property', () => {
      const person = {
        name: 'Joe',
      }
      // check if the property is present, but do not check the value
      cy.wrap(person).should('have.property', 'name')
      // check if the property is present and has a specific value
      cy.wrap(person).should('have.property', 'name', 'Joe')
      // check if the value is a string and matches a regular expression
      cy.wrap(person)
        .should('have.property', 'name')
        // now we are working with the value from person.name
        .should('be.a', 'string')
        .and('match', /joe/i)
      // the assertion "have.property" yields the value
      cy.wrap(person)
        .should('have.property', 'name')
        .should('equal', 'Joe')
      // the assertion "have.key" yields the same object
      cy.wrap(person)
        .should('have.key', 'name')
        // we are still working with the object
        .should('deep.equal', { name: 'Joe' })
    })

    it('multiple properties', () => {
      const address = {
        city: 'Boston',
        state: 'MA',
        zip: '90210',
      }
      // you can specify keys as an array argument
      cy.wrap(address).should('have.keys', ['city', 'state', 'zip'])
      // or as separate arguments
      cy.wrap(address).should('have.keys', 'city', 'state', 'zip')
      // the object has city and state keys (and possible others)
      cy.wrap(address).should('include.keys', ['city', 'state'])
      // can pass keys as separate arguments
      cy.wrap(address).should('include.keys', 'city', 'state')
    })

    it('partial match', () => {
      const address = {
        city: 'Boston',
        state: 'MA',
        zip: '90210',
      }
      cy.wrap(address)
        .should('deep.include', {
          city: 'Boston',
          zip: '90210',
        })
        // continue working with the original object
        .and('deep.include', {
          state: 'MA',
        })
    })
  })

  it('Multiple variants', () => {
    expect('hello').to.be.oneOf(['hi', 'good morning', 'hello'])
    cy.wrap(42).should('be.oneOf', [10, 42, 30])
  })

  it('Approximate value', () => {
    // expected 32.7 to be close to 32 +/- 1
    expect(32.7).to.be.closeTo(32, 1.0)
    cy.wrap(52.9).should('be.closeTo', 50, 3)
  })

  describe('Adding assertions', () => {
    it('multiple assertions', () => {
      cy.contains('a', 'About').should((el) => {
        // we do not care about ID attribute
        expect(el).to.have.attr('href', '/about')
        expect(el).to.have.attr('target', '_blank')
      })
    })

    it('adding custom assertion', () => {
      // add custom Chai assertion to confirm multiple attributes
      chai.use((_chai, utils) => {
        // use "function" syntax to make sure when Chai
        // calls it, the "this" object points at Chai

        function assertAttributes(attributes) {
          Object.keys(attributes).forEach((attr) => {
            const value = this._obj.attr(attr)
            const expectedValue = attributes[attr]
            this.assert(
              value === expectedValue,
              `expected to find attribute **${attr}: ${expectedValue}**, found **${value}**`,
            )
          })
        }
        _chai.Assertion.addMethod('attributes', assertAttributes)
      })

      // now let's use our custom Chai assertion
      // to confirm multiple element attributes at once
      cy.contains('a', 'About').should('have.attributes', {
        href: '/about',
        target: '_blank',
        // but we do not care about "id" attribute
      })
    })
  })
})
